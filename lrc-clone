#!/usr/bin/env bash

# vim: ts=4 et sw=4

if test -z "$1" ; then
    echo "usage: $0 backup.fstab" >&2
    exit 1
fi
if ! test -f "$1" ; then
    echo "ERROR!!! no such file: $1" >&2
    exit 1
fi

set -u
set -e

BACKUP_FSTAB=$1
BOOTDEV=$(cat $BACKUP_FSTAB | sed 's/[ \t]\+$//g' | grep 'boot-loader$' | sed 's/[ \t]\+/ /g' | cut -d\  -f1)
MOUNTS=

die () {
	echo "error: $@, exiting"
	exit 1
}

run-cmd () {
	echo "$1"
	eval "$1"
}

second-guess () {
	echo -n "Use $BOOTDEV? (y/n) [n]: "
	read yesno
	if [ "$yesno" != "y" ] ; then
		exit
	fi
}

trim-comments () {
	sed 's/#.*$//g' | sed 's/[ \t]*$//g' | grep -v "^$"
}

trimfile () {
	cat $1 | trim-comments | awk '{printf "%s %s %s\n", $1, $2, $3}'
}

mount-target-fs () {

    # This function reads the spec fstab and mounts all
    # the filesystems in it.  This is where the destination
    # filesystem is mounted.

	while read dev mnt rest ; do
		if [ "$mnt" != "boot-loader" ] ; then
			mkdir -p $DST${mnt}
			run-cmd "mount $dev $DST${mnt}"
		fi
	done < <(trimfile $BACKUP_FSTAB | csort -k2)
}

clone-fs () {

	# remount everything in /etc/fstab on a temporary mount point.  This
    # way we don't end up trying to backup /proc, /sys, /tmp and other
    # mount points we don't care about.  We only want to backup the
    # filesystems on /etc/fstab.
	while read dev mnt fs rest ; do
		if [ "$dev" != "none" ] ; then
			if [ "$fs" != "" ] ; then
				run-cmd "mount $dev -n -t $fs $SRC${mnt}"
			else
				run-cmd "mount $dev -n $SRC${mnt}"
			fi
		fi
	done < <(trimfile /etc/fstab | csort -k2)

	# rsync the temporary mount point SRC to the destination DST
	echo "cloning $SRC to $DST"
	rsync -aEHSv --delete \
        --exclude var/run \
        --exclude var/tmp \
        --exclude tmp \
		$SRC/* \
		$DST/. || die "rsync failed"

    # These were excluded from the rsync.  Make sure they exist
    # in the destination filesystem.
	mkdir -p $DST/var/run
	mkdir -p $DST/var/tmp
	mkdir -p $DST/tmp
}

rewrite-grub () {
	echo "installing GRUB2 on $BOOTDEV"

    # These are used by many tools these days and will need to be
    # mounted for chrooting to the destination filesystem.  We chroot
    # and do some final setup, such as the boot loader.
	for d in dev proc run sys ; do
		mkdir -p $DST/$d
		mount --bind /$d $DST/$d || die "failed to mount --bind /$d $DST/$d"
	done

# Write an updated grub config
mkdir -p $DST/opt/lrc-backup/grub/etc/default
cat << EOF > $DST/opt/lrc-backup/grub/etc/default/grub
GRUB_DEFAULT=0
GRUB_TIMEOUT=20
GRUB_DISTRIBUTOR="Backup/Clone - $(date)"
#GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=""
EOF

# Write a script which we'll run in the chrooted destination
# filesystem.  This will setup grub.
cat << EOF > $DST/tmp/grub.sh
#!/usr/bin/env bash
sed -i 's/GRUB_TIMEOUT=.*$/GRUB_TIMEOUT=30/g' /etc/default/grub
echo GRUB_DISABLE_OS_PROBER=true >> /etc/default/grub
/opt/lrc-backup/grub/sbin/grub-install $BOOTDEV
/opt/lrc-backup/grub/sbin/grub-mkconfig -o /boot/grub/grub.cfg
EOF

	chmod +x $DST/tmp/grub.sh
	(
		chroot $DST /tmp/grub.sh
	)
	rm $DST/tmp/grub.sh
}

rewrite-fstab () {

	# This function basically reads the spec file
	# and converts it to /etc/fstab in the destination
	# filesystem

	echo "writing new $DST/etc/fstab..."

	mkdir -p $DST/etc

# Write the fstab header
cat << EOF > $DST/etc/fstab
# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
EOF

    # Read the backup fstab as input, write out the UUID's to the
    # updated /etc/fstab on the destination filesystem.
	while read dev mnt fs rest ; do
		if [ "$mnt" != "boot-loader" ] ; then
			local UUID=$(blkid $dev| cut -d\" -f2)
			if [ "$mnt" = "/" ] ; then
				pass=1
			else
				pass=0
			fi

			fs=${fs:=auto}

			echo "UUID=$UUID $mnt $fs defaults 0 $pass" >> $DST/etc/fstab
		fi
	done < <(trimfile $BACKUP_FSTAB | csort -k2)

	echo "none /tmp tmpfs defaults 0 0" >> $DST/etc/fstab

    # Show the result
	cat $DST/etc/fstab
}

tag-clone () {
	# Find the UUID of the root filesystem and append it,
	# along with the date, to the end of /etc/tag.txt on
	# the destination filesystem.  This gives a kind of
    # lineage of the backup.
	srcuuid=unknown
	while read dev mnt rest ; do
		if [ "$mnt" == "/" ] ; then
			srcuuid=$(blkid -s UUID -o value $dev)
			break
		fi
	done < <(cat /proc/mounts)

	mkdir -p $DST/etc/lrc-clone
	echo "$srcuuid $(date)" >> $DST/etc/lrc-clone/tag.txt
}

unmount_all () {
    # walk /proc/mounts unmounting anything that starts
    # with $TMP.  Pause one second between each walk.
    # When nothing in /proc/mounts belongs to this
    # backup, then everything is fully unmounted and the
    # mount points can safely be removed.
	sync
    local count=1
    while (( $count > 0 )) ; do
        count=0
        while read mnt rest ; do
            if [[ $mnt =~ $TMP/.* ]] ; then
                run-cmd "umount $mnt"
                count=$(( $count + 1 ))
            fi
        done < <(cat /proc/mounts | awk '{print $2}' | csort -r)
        if (( $count > 0 )) ; then
            sleep 1
        fi
    done
}

cleanup () {
    unmount_all
	test -d $SRC && rmdir $SRC
	test -d $DST && rmdir $DST
	test -d $TMP && rmdir $TMP
}

main () {
	second-guess

    TMP=$(mktemp -d ${TMP:=/tmp}/backup.XXXXX)
	trap "cleanup ; exit" INT TERM EXIT
    echo "tmp is $TMP"
    mkdir -p $TMP/{src,dst}
    DST=$TMP/dst
    SRC=$TMP/src
	mount-target-fs

	clone-fs
	rewrite-fstab
	rewrite-grub
	tag-clone
}

main

